/**************************************************************

  	     CP/M 2.2 SYSGEN Overlayer from HEX Files

	  Copyright (c) 2026 RCL9. All Rights Reserved.

		     By RCL9 - Feb 2 2026

		(Rob's Retro Computing Archive)
		RetroComputingArchive@gmail.com
			github.com/rcl9

This program allows a CP/M 2.2 "SysGen" image to be selectively
overlaid with ABOOT.HEX, BDOS2.HEX, ZCCP12.HEX and/or CBIOS2.HEX
(or, named files of your own choosing). The SysGen image can then
be written to the two system tracks of an Exidy Sorcerer DiskJockey
2D/B CP/M 2.2 diskette.

These .hex files are made from the original .ASM and .MAC files
on a running version of CP/M 2.2 (Yaze-AG in this case).

	Written to be compiled with Microsoft Visual Studio.

***************************************************************/

// The name of the .hex files generated by the assemblers in CP/M 2.2
#define Nc_COLD_BOOT_FILENAME		"aboot.hex"
#define Nc_CCP_FILENAME			"zccp12.hex"
#define Nc_BDOS_FILENAME		"bdos22.hex"
#define Nc_CBIOS_FILENAME		"cbios2.hex"

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#define	TRUE	1
#define	FALSE	0

// This memory image will be saved out to the first two tracks of the Morrow DJ2D diskette via
// the Sysgen.com program.

// These are my assumptions about the portions of tracks 0 and 1 used by the cold boot code,
// the CCP, BDOS (and the remaining for the CBIOS)
//
// According to the docs at the top of CBIOS.ASM there are 16 128-byte sectors dedicated to the
// cold boot, warm boot and "firmware" before the CPP and the remaining portions of CP/M reside.
#define Nc_TRACK01_RESERVED	(16 * 128)	// According to the map shown at the top of CBIOS.ASM
#define Nc_TRACK01_CCP		0x800		// The size of the CCP in CP/M 2.2 is 0x800 bytes
#define Nc_TRACK01_BDOS		0xE00		// The size of the BDOS in CP/M 2.2 is 0xE00 bytes
// The CBIOS sits in the remaining memory

// Memory image at 0900H through to 227FH in the SysGen image with TPA at 0100H.
// These #defines are the actual memory location where each component is located in the SysGen Image/
// However, for this .exe utility program the actual data is 0-based relative to 0x100.
#define Nc_MEM_LOC__TPA		0x100		// SysGen normally loads in the file at this memory address (TPA)
#define Nc_MEM_LOC__BOOT	0x900		// File offset 0x800. 128 byte boot sector
#define Nc_MEM_LOC__CCP		(Nc_TRACK01_RESERVED + Nc_MEM_LOC__BOOT)	// CCP size 0x800
#define Nc_MEM_LOC__BDOS	(Nc_TRACK01_CCP + Nc_MEM_LOC__CCP )		// BDOS size 0xE00
#define Nc_MEM_LOC__CBIOS	(Nc_TRACK01_BDOS + Nc_MEM_LOC__BDOS) 	// CBIOS runs to the end of memory.

	int
Overlay_HEX_File_Over_Sysgen_Image_File(
	const std::string& filename,
	char	*sysgen_image_ptr,
	int	max_bytes_to_read );

// -------------------------------------------------------------------------------------------

	int
main (int argc, char *argv[])
{
	FILE	*inf, *outf;

	fprintf (stderr, "This program overlays %s, %s, %s and/or %s\n",
		Nc_COLD_BOOT_FILENAME, Nc_CCP_FILENAME, Nc_BDOS_FILENAME, Nc_CBIOS_FILENAME );
	fprintf (stderr, "(hex files) over an existing CP/M 2.2 compatible SYSGEN image for writing to the first two\n");
	fprintf (stderr, "system tracks of an Exidy Sorcerer DiskJockey 2D/B CP/M 2.2 diskette.\n");
	fprintf (stderr, "By RCL9. RetroComputingArchive@gmail.com. github.com/rcl9.\n\n");

	if ( argc < 3) {
		fprintf (stderr, "Usage:\n\
\t%s\n\n\
\tOne or more of the following 4 arguments:\n\
\t-a[optional cold-boot .hex filename, default = '%s']\n\
\t-c[optional CCP .hex filename, default = '%s']\n\
\t-d[optional BDOS .hex filename, default = '%s']\n\
\t-b[optional CBIOS .hex filename, default = '%s']\n\
\t-p (which prevents the SysGen 800H padding bytes from being written out)\n\
\n\
\tinput_SysGen_filename.bin\n\
\toutput_SysGen_filename.bin\n",
	argv[0],
	Nc_COLD_BOOT_FILENAME,
	Nc_CCP_FILENAME,
	Nc_BDOS_FILENAME,
	Nc_CBIOS_FILENAME );

		exit (1);
	}

	char cold_boot_hex_filename[4096];
	char ccp_hex_filename[4096];
	char bdos_hex_filename[4096];
	char cbios_hex_filename[4096];

	strcpy( cold_boot_hex_filename, Nc_COLD_BOOT_FILENAME );
	strcpy( ccp_hex_filename, Nc_CCP_FILENAME );
	strcpy( bdos_hex_filename, Nc_BDOS_FILENAME );
	strcpy( cbios_hex_filename, Nc_CBIOS_FILENAME );

	bool overlay_cold_boot = FALSE;
	bool overlay_ccp = FALSE;
	bool overlay_bdos = FALSE;
	bool overlay_cbios = FALSE;

	char in_filename[4096];
	char out_filename[4096];
	in_filename[0] = out_filename[0] = '\0';

	bool do_not_write_out_SysGen_Padding = FALSE;

	/* Pick up any command line options */
	int fnum = 0;
	if (argc >= 1) {
		while (argc > 1) {
			char *str = argv[1];
			if (str[0] == '-') {
				_strlwr(++str);

				if ( *str == 'a') {
					overlay_cold_boot = TRUE;
					++str;

					// Get the optional filename
					if ( strlen(str) )
						strcpy( cold_boot_hex_filename, str );
				}
				else if ( *str == 'c') {
					overlay_ccp = TRUE;
					++str;

					// Get the optional filename
					if ( strlen(str) )
						strcpy( ccp_hex_filename, str );
				}
				else if ( *str == 'd') {
					overlay_bdos = TRUE;
					++str;

					// Get the optional filename
					if ( strlen(str) )
						strcpy( bdos_hex_filename, str );
				}
				else if ( *str == 'b') {
					overlay_cbios = TRUE;
					++str;

					// Get the optional filename
					if ( strlen(str) )
						strcpy( cbios_hex_filename, str );
				}
				else if ( *str == 'p')
					do_not_write_out_SysGen_Padding = TRUE;
			} else if (str && strlen(str)) {
				// Pick up the two filenames
				if ( !strlen(in_filename) )
					strcpy( in_filename, str );
				else if ( !strlen(out_filename) )
					strcpy( out_filename, str );
			}

			argv++;
			argc--;
		}
	}

	if ( !strlen(in_filename) || !strlen(out_filename)) {
		fprintf (stderr, "The input and output SysGen filenames need to be provided.\n");
		exit (2);
	}

	// Read the original file into memory
	inf = fopen ( in_filename, "rb" );
	if (!inf) {
		fprintf (stderr, "Error opening the SysGen file '%s' for reading.\n", in_filename );
		exit (2);
	}
	if (fseek( inf, 0L, SEEK_END) != 0) {
		fprintf (stderr, "Error while seeking to the end of the file %s.\n", in_filename );
		exit (2);
	}
	int size = ftell( inf );
	if (size == -1L) {
		fprintf (stderr, "Error from ftell() for the file %s.\n", in_filename );
		exit (2);
	}
	if (fseek( inf, 0L, SEEK_SET) != 0) {
		fprintf (stderr, "Error from fseek( end ) for the file %s.\n", in_filename );
		exit (2);
	}
	char *sysgen_image_ptr = (char *) malloc( size );
	int num_bytes_read = (int) fread( sysgen_image_ptr, 1, size, inf );
	fclose(inf);

	fprintf (stderr, "Offsets (0-based) within the files:\n");
	fprintf (stderr, "\tBoot code = %xH (len = %xH, 26 * 128 sectors)\n", Nc_MEM_LOC__BOOT - Nc_MEM_LOC__TPA, Nc_TRACK01_RESERVED);
	fprintf (stderr, "\tCCP = %xH (len = %xH)\n", Nc_MEM_LOC__CCP - Nc_MEM_LOC__TPA, Nc_TRACK01_CCP);
	fprintf (stderr, "\tBDOS = %xH (len = %xH)\n", Nc_MEM_LOC__BDOS - Nc_MEM_LOC__TPA, Nc_TRACK01_BDOS);
	fprintf (stderr, "\tCBIOS = %xH\n\n", Nc_MEM_LOC__CBIOS - Nc_MEM_LOC__TPA);

	if ( cold_boot_hex_filename && overlay_cold_boot ) {
		// Determine the maximum size of the cold boot
		int max_cold_boot_size = Nc_TRACK01_RESERVED;

		int num_bytes_read = Overlay_HEX_File_Over_Sysgen_Image_File(
			cold_boot_hex_filename,
			sysgen_image_ptr + ( Nc_MEM_LOC__BOOT - Nc_MEM_LOC__TPA ),
			max_cold_boot_size );

		fprintf (stderr, "Cold boot loader: %d max size, %d bytes read from file '%s'.\n", max_cold_boot_size, num_bytes_read, cold_boot_hex_filename );
	}

	if ( ccp_hex_filename && overlay_ccp ) {
		// Determine the maximum size of the CCP
		int max_CCP_size = Nc_TRACK01_CCP;

		int num_bytes_read = Overlay_HEX_File_Over_Sysgen_Image_File(
			ccp_hex_filename,
			sysgen_image_ptr + ( Nc_MEM_LOC__CCP - Nc_MEM_LOC__TPA ),
			max_CCP_size );

		fprintf (stderr, "CCP: %d max size, %d bytes read from file '%s.\n", max_CCP_size, num_bytes_read, ccp_hex_filename );
	}

	if ( bdos_hex_filename && overlay_bdos ) {
		// Determine the maximum size of the BDOS
		int max_bdos_size = Nc_TRACK01_BDOS;

		int num_bytes_read = Overlay_HEX_File_Over_Sysgen_Image_File(
			bdos_hex_filename,
			sysgen_image_ptr + ( Nc_MEM_LOC__BDOS - Nc_MEM_LOC__TPA ),
			max_bdos_size );

		fprintf (stderr, "BDOS: %d max size, %d bytes read from file '%s.\n", max_bdos_size, num_bytes_read, bdos_hex_filename );
	}

	if ( cbios_hex_filename && overlay_cbios ) {
		// Determine the maximum size of the CBIOS
		int max_cbios_size = size - Nc_MEM_LOC__CBIOS - Nc_MEM_LOC__TPA;

		int num_bytes_read = Overlay_HEX_File_Over_Sysgen_Image_File(
			cbios_hex_filename,
			sysgen_image_ptr + ( Nc_MEM_LOC__CBIOS - Nc_MEM_LOC__TPA ),
			max_cbios_size );

		fprintf (stderr, "CBIOS: %d max size, %d bytes read from file '%s.\n", max_cbios_size, num_bytes_read, cbios_hex_filename );
	}

	fprintf (stderr, "%d bytes written to the output file.\n", size );

	fprintf (stderr, "\nNote: the maximum allowable SysGen file size is (128*26+8*1024) = 11520 bytes.\n");

	outf = fopen ( out_filename, "wb");
	if (!outf) {
		fprintf (stderr, "Error opening output SysGen raw file '%s'.\n", out_filename );
		exit (2);
	}

	if ( do_not_write_out_SysGen_Padding )
		// Do not write out the useless SysGen padding bytes. This will basically generate
		// a raw image of the CP/M disk.
		fwrite( sysgen_image_ptr + 0x800, 1, size, outf);
	else
		fwrite( sysgen_image_ptr, 1, size, outf);

	fclose (outf);
}

// Function to convert a hex string to an integer
unsigned int hexToUint(const std::string& hexStr) {
    unsigned int value;
    std::stringstream ss;
    ss << std::hex << hexStr;
    ss >> value;
    return value;
}

	int
Overlay_HEX_File_Over_Sysgen_Image_File(
	const std::string& filename,
	char	*sysgen_image_ptr,
	int	max_bytes_to_read )
{
	int num_bytes_read = 0;

    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open source hex file " << filename << std::endl;
    }

    int current_address = -1;

    std::string line;
    while (std::getline(file, line)) {
        if (line.empty() || line[0] != ':') continue;

        // Extract fields
        unsigned int byteCount = hexToUint(line.substr(1, 2));
        int address = hexToUint(line.substr(3, 4));
        unsigned int recordType = hexToUint(line.substr(7, 2));
        // Data starts at index 9, length is byteCount * 2 hex digits
        std::string dataStr = line.substr(9, byteCount * 2);
        unsigned int checksumFromFile = hexToUint(line.substr(9 + byteCount * 2, 2));

	  if ( current_address == -1 )
		current_address = address;
	  else {
		// Take into condideration data block data offsets which make the address counter jump
		// (ie. for DB, DW and DS statements in the source .asm file)
		while (current_address < address) {
			*sysgen_image_ptr = 0;
			++sysgen_image_ptr;
			++num_bytes_read;

			if ( num_bytes_read >= max_bytes_to_read && max_bytes_to_read )
				return num_bytes_read;
			++current_address;
		}
	  }

        // Calculate checksum locally for validation
        unsigned int calculatedChecksum = byteCount + (address >> 8) + (address & 0xFF) + recordType;
        for (size_t i = 0; i < dataStr.length(); i += 2) {
            calculatedChecksum += hexToUint(dataStr.substr(i, 2));
        }
        calculatedChecksum = (unsigned int)((unsigned char)(~calculatedChecksum + 1)); // Two's complement

        // Output information (or store in memory)
//        std::cout << "Record: Type=" << recordType << ", Address=0x" << std::hex << std::setw(4) << std::setfill('0')
//                  << address << ", Count=" << std::dec << byteCount << ", Checksum Valid="
//                  << (calculatedChecksum == checksumFromFile ? "Yes" : "No") << std::endl;

        // Process data if it's a data record (Type 00)
        if (recordType == 0x00) {
            // std::cout << "Data: ";
            for (size_t i = 0; i < dataStr.length(); i += 2) {
                unsigned int dataByte = hexToUint(dataStr.substr(i, 2));
                // std::cout << std::hex << std::setw(2) << std::setfill('0') << dataByte << " ";

			*sysgen_image_ptr = dataByte;
			// *sysgen_image_ptr = 0XEE;
			++sysgen_image_ptr;
			++current_address;
			++num_bytes_read;

			if ( num_bytes_read >= max_bytes_to_read && max_bytes_to_read )
				return num_bytes_read;

            }
            // std::cout << std::endl;
        } else if (recordType == 0x01) {
            // std::cout << "End of File record reached." << std::endl;
        }
    }

	return num_bytes_read;
}
